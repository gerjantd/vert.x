:scrollbar:
:data-uri:
:toc2:

== Red Hat OpenShift Application Runtimes - Vert.x lab

In this lab you will develop the Catalog microservice for the Coolstore application. The catalog microservice is responsible for retrieving products from (and adding to) the catalog. This functionality is exposed over a REST API. Product entities are stored in MongoDB.

The catalog service will be developed using Vert.x

TODO: Elaborate on reasons behind the choice for Vert.x

The lab starts with a application skeleton. During the lab you will add the missing pieces to obtain a functional application.

== Set up the lab environment

TODO: instructions to clone and import the application skeleton into the IDE

TODO: access to OCP environment

== Application architecture

The application consists of a single maven project, and is organized as three verticles:

* The API verticle, which exposes the REST API for the service
* The Catalog service verticle, which handes the interaction with the datastore (MongoDB) and exposes this functionality as a service to the API Verticle
* The Main verticle, responsible for initialization and wiring the different components together.

The three verticles are deployed together on one JVM.

Note that this structure is probably overkill and is purely done for educational purposes, to illustrate how multiple verticles can interact within one application. The required functionality could easily have been fitted into a single verticle. On the other hand, as the catalog service evolves over time and gets more functionality, it could make sense to split it up in different projects, one per verticle for example.

=== Project structure

TODO: describe project structure

TODO: review maven pom.xml

The application is built with maven. From the command line:

----
$ mvn clean package
----

== Lab Solution

During this lab, you will complete the implementation of the catalog microservice. The instructions provided should be sufficient to complete the different tasks. +
In the case you are lost or could use some help, the complete solution of the lab is provided in the `solution` folder of the lab material.

== Catalog Service verticle

This verticle is responsible for retrieving and storing product entities into the MongoDB datastore.

For the first iteration of this microservice, you only need two operations: retrieve all the product entities from the the catalog, and add a product to the catalog. These operations are exposed as a Vert.x Event Bus service.

The Vert.x product comes with an asynchronous client for MongoDB. This client is a wrapper around the _MongoDB Async Driver_. It allows non-blocking interaction with MongoDB, and fast serialization/seserialization between Vert.x JSON and MongoDB BSON (the native JSON format used by MongoDB).

The application code contains the service interface, the Product entity class, and the verticle definition class.

What is missing:

* The service implementation
* The service proxy code generated by Vert.x
* Unit tests for the service

=== Product entity class

Vert.x has native integration for JSON, and JSON is the natural and preferred data format used inside Vert.x applications. From a developer point of view however, handling JSON structures directly can be tedious and error prone. In Vert.x applications, you can still use POJOs to model your entities, and use mappers to marshal from and to JSON.

When using Vert.x Event Bus services, the conversion from Entities to and from JSON will be done by the generated proxy code.

For the catalog service, we have only one entity, named Product, which is pretty simple and has only four attributes for the moment.

The application code already contains the `Product` class, in the `com.redhat.coolstore.catalog.model` package.

In order to use the Product class as a data object for Event Bus services, it must obey to a set of constraints:

* It must be annotated with `DataObject`
* It must have an empty constructor, and a constructor taking a `JsonObject` as parameter
* It must have a `toJson()` method building a `JsonObject` representing the current object
* Fields must be properties with getters and setters

{empty} +

. Review the code of the `Product` class. +
At the moment it only contains fields with getters and setters.
. Annotate the class with the `@DataObject` annotation. +
The `DataObject` annotation is part of the `vertx-codegen` jar, which has been added to the project dependencies in the `pom.xml` file.
. Add a constructor to the class which takes a `JsonObject` as a parameter.
* The implementation of the constructor sets the fields of the class instance to the values contained in the JSON object.
* Use the `JsonObject.getString()` and `JsonObject.getDouble()` methods to get the values from the JsonObject
. Implement the `toJson()` method which returns a `JsonObject` representing the product.
* Use the `JsonObject.put()` method to set values in the `JsonObject`.
. The Vert.x code generation functionality requires that all packages containing classes annotated with `@DataObject` must be annotated with the `@ModuleGen` annotation.
* Open the `package-info.java` file in the `com.redhat.coolstore.catalog.model` package, and add the following annotation:
+
[source,java]
----
@io.vertx.codegen.annotations.ModuleGen(groupPackage = "com.redhat.coolstore.catalog.model", name = "coolstore-catalog-model")
package com.redhat.coolstore.catalog.model;
----
. Execute a maven build to make sure the class compiles.

=== Service Interface

. Review the `CatalogService` interface in the `com.redhat.coolstore.catalog.verticle.service` package. +
The interface exposes two methods, to retrieve all the Products in the catalog, and to add a Product to the catalog. A third method `ping` will be used later in the labs to implement application health checks.
* Methods exposed as Event bus service methods do not return a result, but `void`. The return object is encapsulated in the `Handler` parameter.
+
[source,java]
----
void getProducts(Handler<AsyncResult<List<Product>>> resulthandler);
----
* The `CatalogService` interface contains a convenience method to obtain an implementation instance of the service.
. To generate the Event bus proxy classes, the service interface must be annotated with the `@ProxyGen` annotation.
* Annotate the `CatalogService` with the `@ProxyGen` annotation
. The Vert.x code generation functionality requires that all packages containing classes annotated with `@ProxyGen` must be annotated with the `@ModuleGen` annotation.
* Open the `package-info.java` file in the `com.redhat.coolstore.catalog.verticle.service` package, and add the following annotation:
+
[source,java]
----
@io.vertx.codegen.annotations.ModuleGen(groupPackage = "com.redhat.coolstore.catalog.model", name = "coolstore-catalog-model")
package com.redhat.coolstore.catalog.model;
----
. To generate the code for the Event Bus service proxy objects, the `io.vertx.codegen.CodeGenProcessor`  annotation processor must run as part of the compile step. +
When using maven this can be done by adding the anotation processor to the maven compile plugin.
* Review the maven compiler plugin configuration in `<build><plugins>` section of the project `pom.xml` file:
+
[source,java]
----
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <annotationProcessors>
            <annotationProcessor>io.vertx.codegen.CodeGenProcessor</annotationProcessor>
          </annotationProcessors>
          <generatedSourcesDirectory>
            ${project.basedir}/src/main/generated
          </generatedSourcesDirectory>
        </configuration>
      </plugin>
----
. Run a maven build.
+
----
$ mvn clean package
----
+
As part of the compile step, the Vert.x code generator generates the code for the event bus service proxy classes.
. By default, in JBDS, the `src/main/generated` folder is not added to the source folders of the project. This will generate compile errors when you want to use these generated classes.
* In JBDS, navigate to the `src/main/generated` folder in the project.
* Right-click on the `generated` folder, and select `Build path -> Use As Source Folder`
+
image::images/jbds_generated_source_folder.png[]
* Note that two classes were generated by the Vert.x generator: `CatalogServiceVertxProxyHandler` and `CatalogServiceVertxEBProxy`. The first one is used when registering the service - you will do that later in the lab - and the second is the proxy class to used by clients.
* Review the `CatalogServiceVertxEBProxy` class, more specifically the `getProducts()` and `addProducts()` methods, which contain the code to interact with the Catalog service over the event bus.
. Add a static convenience method to the `Catalog` interface to create a proxy instance. The method returns a instance of the `CatalogServiceVertxEBProxy` initialized with the Vertx instance and the value of the `ADDRESS` field. The value of `ADDRESS` is the Event Bus address used to communicate with the Catalog service over the Vert.x Event Bus.

=== Service implementation

The service implementation class is `CatalogServiceImpl` in the `com.redhat.coolstore.catalog.verticle.service` package.

. Review the code of the `CatalogServiceImpl` class.
* To interact with MongDB, the service uses an instance of the Vert.x `MongoClient`. This client is passed in through the constructor. The client is created and configured later in the lab.
* The Vert.x MongoDB client uses an asynchronous programming model. Results of queries and other operations against MongoDB are encapsulated in an `AsyncResult` object.
* The Vert.x MongoDB client uses `JsonObject` as payload
* The `addProduct()` method is already implemented.
** To add new products in MongoDB, use the `MongoClient.save()` method. The product is persisted in the _products_ collection. In MongoDB, a collection is somewhat similar to a table in a RDBMS.
** The `_id` in the product JSON is used in Mongo as a document identifier, a bit like a primary key.
** The `MongoClient.save()` method returns the id of the persisted entity - or null if the entity already has an `_id` field.
. Implement the `getProducts()` method. This methods returns all the products in the database. +
Some hints:
* Use the `MongoClient.find()` method. This method takes as parameters the collection to search (_products_), a query definition as JsonObject, and a handler. To find all the elements in a collection, use an empty `JSONObject`.
* The type of the handler for the `MongoClient.find()` method is `<AsyncResult<List<JsonObject>>`. +
In the handler implementation, transform the `List<JsonObject>` to `List<Person>` - use Java8 Streams!
* Use a `Future` for the `handle()` method of the service method handler:
+
[source,java]
----
public void getProducts(Handler<AsyncResult<List<Product>>> resulthandler) {
    client.find("products", new JsonObject(), ar -> {
        // (...)
        List<Product> products = ...

        resultHandler.handle(Future.succeededFuture(products));
        // (...)
    });

}
----
* Don't forget to handle failures!

=== Catalog Service Verticle

The Catalog Service verticle is defined in the `CatalogVerticle` class in the `com.redhat.coolstore.catalog.verticle.service` package.

. Review the code of the `CatalogVerticle`.
* The class extends `AbstractVerticle`. Extending `AbstractVerticle` is easier than implementing the `Verticle` interface when developing a Verticle. +
A Verticle implementation will typically override the `start()` method of `AbstractVerticle`. This method is called right after the verticle has been deployed on the Vert.x instance. +
If cleanup has to be done when a Verticle is shut down, you can override the `stop()` method.
. In the `start()` method of the `CatalogVerticle` verticle:
** The MongoDB client is instantiated.
+
[source,java]
----
client = MongoClient.createShared(vertx, config());
----
+
Refer to the documentation of the Vert.x MongoDB client (http://vertx.io/docs/vertx-mongo-client/java/) for more information about the client and how to use it.
+
The `config()` method of `AbstractVerticle` returns the configuration of the application, and is usually specified when the verticle is deployed.
** The catalog event bus service is registered:
+
[source,java]
----
CatalogService service = CatalogService.create(vertx, config(), client);
ProxyHelper.registerService(CatalogService.class, vertx, service, CatalogService.ADDRESS);
----
** Finally, the `Future` passed as argument of the `start()` method is completed.
. In the `stop()` method, the MongoDB client is closed, which releases all associated resources.

=== Unit tests

The unit tests for the Catalog Verticle are somewhat complicated by the fact that you interact with a database. A possible solution is to mock out the Vert.x MongoDB client driver. The approach chosen here is to use an embedded MongoDB instance. In this sense our tests are somewhat in the middle between a unit test and an integration test.

The unit tests are located in the `com.redhat.coolstore.catalog.verticle.service` package of the `src/test/java` project folder.

. Review the code in the `MongoTestBase` class. +
This class contains the code to start and stop the embedded MongoDB instance before and after the tests, as well as emtying the database between individual tests.
. Open the `CatalogServiceTest` class. This class extends `MongoTestBase`, and contains the unit tests for our service.
* When using JUnit, Vert.x unit test classes can use the `VertxUnitRunner` test runner, which greatly facilitates writing asynchronous tests.
* Annotate the `CatalogServiceTest` class with the `@RunWith(VertxUnitRunner.class)`
* Uncomment the `@Before`, `@After` and `@Test` annotations. +
Note that these annotations were commented out because they would cause maven builds to fail without the `@RunWith(VertxUnitRunner)` class annotation.
. Note that the methods annotated with `@Before`, `@After` and `@Test` take a `TestContext` object as argument. The test context is used for performing test assertions and manage the completion of the test.
. Review the `setup()` method, which will be executed before every individual test. Note the instantiation of the `Vertx` object and the usage of `Async` to handle asynchronous methods. +
The `setup()` method will only return when the `Async` object is completed or failed (in the `dropCollections()` method), or times out after 10 seconds. This technique ensures that the test setup is complete before starting with the test methods.
. Review the `testAddProduct()` method. This test verifies the `addProduct()` method of the catalog service. +
. Implement a test for the `testGetProducts()` method of the catalog service. +
In your test:
* Insert two or more products in MongoDB. Use the `MongoClient.save()` method to do so.
* Retrieve the products from Mongo using the `getProducts()` method.
* Verify that no failures happened, that the number of products retrieved corresponds to the number inserted, and that the retrieved product values match what was inserted.
. Run and verify your tests with the JUnit test runner in JBDS, or with maven at the command line:
+
----
$ mvn clean test
----

== API Verticle

This verticle is responsible for exposing the REST API for the catalog microservice. The microservice exposes two operations, one to retrieve all the products from the catalog, and the second to add a new product to the catalog. +
To implement the REST API, you use the Vert.x Web module. The project `pom.xml` file already contains the dependency to that module.

=== Routes and HttpServer

. Review the code of the `ApiVerticle` class in the `com.redhat.coolstore.catalog.api` package. +
The class extends `AbstractVerticle`, but it does not do a lot at the moment.
. Implement the `start()` method. In this method create the routes for the REST API. The code to create the router is already present. +
Add the following routes to the router:
* A route for HTTP GET requests that matches the "/products" path. The handler for this route is implemented by the `getProducts()` method.
* A route for the path "/product*" to which a `BodyHandler` is attached.
* A route for HTTP POST requests that matches the "/product" path. The handler for this route is implemented by the `addProduct()` method.
This route takes its payload from the HTTP request body.
. Still in the `start()` method, create a HTTP server.
* Use the `Router` as request handler
* Use the verticle configuration to obtain the port to listen to. Get the configuration from the `config()` method of AbstractVerticle, which returns a JsonObject. +
Look for the key "catalog.http.host", which returns an Integer. The default value (if the key is not set in the configuration) is 8080.
* If the HTTP server is correctly instantiated, complete the `Future`. If there is a failure, fail the `Future`.
. Implement the `getProducts()` method. In the implementation:
* Call the `getProducts()` method of the CatalogService.
* In the handler, transform the `List<Product>` response to a `JsonArray` object. The `JsonArray` array object is the Vert.x representation of a JSON list.
* Put a "Content-type: application/json" header on the `HttpServerResponse` object, which can be obtained through the `response()` method of `RoutingContext`.
* Write the `JsonArray` to the `HttpServerResponse`, and end the response.
* If the service `getProducts()` method returns a failure, fail the `RoutingContext`. This will send a HTTP response code 500 to the caller.
. Implement the `addProduct()` method. In the implementation:
* Obtain the body contents from the `RoutingContext`. Expect the body to be JSON, so use the `RoutingContext.getBodyAsJson()` method.
* Transform the JSON payload to a `Product` object.
* Call the `addProduct()` method of the CatalogService. If the call succeeds, set a HTTP status code 201 on the `HttpServerResponse`, and end the response. If the call fails, fail the `RoutingContext`.

=== Unit tests

To test the API Verticle, you can start a Vert.x instance in your test, and deploy the verticle in it. To avoid possible port conflicts, the HTTP server started by the verticle binds to a random port, which allows us to invoke the routes in the test. Vert.x Web comes with a HTTP Client that is very well suited for this.

The unit tests are located in the `com.redhat.coolstore.catalog.api` package in the `src/test/java` folder.

. Open the `ApiVerticleTest` class.
. Annotate the class with the `@RunWith(VertxUnitRunner.class)` annotation.
. Uncomment the `@Before`, `@After` and `@Test` annotations.
. Review the `setup()` method. In the method:
* A vertx instance is instantiated
* The `TestContext` exception handler is set on the vertx instance. This allows you to use Hamcrest asserts in your tests.
* An instance of `APIVerticle` is created. A mock implementation of `CatalogService` is injected through the verticle constructor (these are unit tests, not end-to-end integration tests). To mock the service, the _Mockito_ framework is used (http://site.mockito.org/).
* When deploying the verticle, a `DeploymentOptions` object is passed as parameter to the deploy method. This object contains the configuration for the verticle, more precisely the value of the port the HTTP server should bind to.
* The `TestContext.asyncAssertSuccess()` method ensures that the test methods are not executed before deployment is marked complete and successful.
. Review the `testAddProduct()` method.
* This method uses the Vert.x Web HTTP Client to execute a POST request to the "/product" endpoint.
* In the response handler the return code is verified, as well as the expected invocation of the CatalogService.
* Notice the usage of `Async` to ensure that the test is only marked complete after handling the asynchronous response to the request.
* Notice the usage of the `TestContext` exception handler on the `HttpClientRequest` object. This ensures that assert exceptions are reported as test failures.
. Implement the `testGetProducts()` method.
* Stub the `getProducts()` method of the `CatalogService` mock to return a `List<Product>`
* Use the Vert.x Web client to execute a GET request to the "/products" endpoint. Use the `get()` method of the HTTP client.
* Verify that the return code of the request is equal to 200, and that the response has a header "Content-type: application/json".
* Use the `BodyHandler` method of the `HttpClientResponse` object to obtain and verify the response body.
+
[source,java]
----
vertx.createHttpClient().getNow(port, "localhost", "/products", response -> {
            // verify response code, headers
            response.bodyHandler(body -> {
                JsonArray json = body.toJsonArray();
                // verify the response object
                async.complete();
            });
        });
----
. Run and verify your tests with the JUnit test runner in JBDS, or with maven at the command line:
+
----
$ mvn clean test
----

== Main Verticle

This is the starting point of the catalog microservice. In this verticle all components are wired together.

=== Main Verticle class

. Review the code of the `MainVerticle` class in the `com.redhat.coolstore.catalog.verticle` package. +
The class extends `AbstractVerticle`, but it does not do a lot at the moment.
. Implement the `deployVerticles()` method. In this method:
* Create a proxy for the `CatalogService`. Use the static `CatalogService.createProxy()` method.
* Create an instance of `ApiVerticle` and `CatalogVerticle`.
* Deploy the verticles.
* Make sure to pass the verticle configuration object as part of the deployment options:
+
[java,source]
----
DeploymentOptions options = new DeploymentOptions();
options.setConfig(config());
----
* Use `Future` objects to get notified of successful deployment (or failure) of the verticle deployments.
* Use a `CompositeFuture` to coordinate the deployment of both verticles. +
`CompositeFuture` wraps a list of `Future`, and is useful when several futures need to be coordinated. For example, the `ComposositeFuture.all` method succeeds when all its futures are succeeded, and fails when any future is failed.
+
[source,java]
----
Future f1 = Future.future();
Future f2 = Future.future();

CompositeFuture.all(f1, f1).sethandler(ar -> {
    //handle success or failure
});
----
* Complete or fail the `startFuture` Future depending on the result of the CompositeFuture.

=== Packaging

A convenient way to package and run Vert.x application is to build a fat jar (or uber-jar), which contains all the dependencies needed to run the application. +
The fat jar is executable, and can be launched with `java -jar <application.jar>`

When using maven, the Fabric8 Vert.x plugin (https://vmp.fabric8.io/) can be used to build the fat jar. +
The Fabric8 Vert.x plugin adds MANIFEST.MF entries during the packaging process. These entries control how the application is launched. +
The plugin adds the following entries to the MANIFEST.MF:

* Main-Class : The main class used to start the application, defaults to _io.vertx.core.Launcher_
* Main-Verticle : The main verticle, i.e. the entry point of your application

{empty} +

. Review the `pom.xml` file, more specifically the configuration of the Fabric8 Vert.x plugin
* The `vert.x:package` goal is attached to the `package` maven goal
* The main verticle is set as a property `vertx.verticle` in the pom file.
. Build the application with maven. From the command line:
+
----
$ mvn clean package
----
. Check that a fat jar was built in the `target` directory of the project (check the size of the built jar):
+
----
$ ls -lgG target/*.jar
-rw-rw-r--. 1 9357956 May 28 10:44 target/catalog-service-1.0.0-SNAPSHOT.jar
----

== Deployment on OpenShift

=== Configuration

Out of the box, Vert.x supports external configuration through a JSON file containing key value pairs. This JSON file is passed to the verticle through the command line using the `-conf` parameter. +
Example configuration file:

----
{
  "http.port" : 8082
}
----

Usage example:

----
$ java -jar my-first-app-1.0-SNAPSHOT-fat.jar -conf conf/my-application-conf.json
----

The recommended way to configure applications on OpenShift is with _ConfigMaps_. Using a ConfigMap ensures the configuration is decoupled from the application image and keeps the application image portable. Using a ConfigMap, configuration data will be injected into the container at runtime.

The Vert.x Config project provides support for offers multiple configuration syntaxes (JSON, properties, YAML ...) and multiple configuration stores (files, directories, HTTP, git, system properties, environment variables, Kubernetes ConfigMap ...)

As the target platform for the Coolstore application is OpenShift, you will use the Vert.x support for Kubernetes ConfigMaps to retrieve the configuration for the catalog application.

. Add the required dependencies to the pom.xml file. +
In order to use the Vert.x Kubernetes Configmap support, you need the following dependencies (groupId:artifactId):
* `io.vertx:vertx-config`
* `io.vertx:vertx-config-kubernetes-configmap`
* `io.vertx:vertx-config-yaml` - allows to express the configuration as YAML file rather than JSON
. Implement the `start()` method of `MainVerticle`. In this method:
* Create a `ConfigStoreOptions` instance.
* Set the type to "configmap" and the format to "yaml".
* Configure the `ConfigStoreOptions` instance with the name and the key of the configmap
+
In OpenShift, a Configmap has a name, and represents a key-value pair store. In order to retrieve the application configuration, the Vert.x ConfigStore needs to know the name of the ConfigMap, and the key under which the configuration file is bound. In this lab you will hard-code the values.
+
[source,java]
----
ConfigStoreOptions appStore = new ConfigStoreOptions()
// ...
appstore.setConfig(new JsonObject()
                .put("name", "app-config")
                .put("key", "app-config.yaml"));
----
+
A more robust implementation could use environment variables for the Configmap name and key.
* Create a `ConfigRetrieverOptions` instance
* Add the `ConfigStoreOptions` instance as store to the `ConfigRetrieverOptions` instance
* Create a `ConfigRetriever` instance with the `ConfigRetrieverOptions` instance
* Use the `ConfigRetriever` instance to retrieve the configuration
* If the retrieval is successful, call the `deployVerticles` method, otherwise fail the `startFuture` object.

=== Health Checks

In OpenShift, the health of an application is assessed using probes, which is an action that is executed periodically by the OCP cluster to perform diagnostics on running containers. +
Two types of probes exist, each serving a different purpose:
* Liveness Probe : checks if the container in which it is configured is still running. If the liveness probe fails, the container is killed by the cluster, which will be subjected to its restart policy.
* Readiness Probe : determines if a container is ready to service requests. If the readiness probe fails a container, the endpoints controller ensures the container has its IP address removed from the endpoints of all services. A readiness probe can be used to signal to the endpoints controller that even though a container is running, it should not receive any traffic from a proxy.

The Vert.x Health Checks component provides a Vert.x Web handler on which you can register procedures testing the health of the application. The handler computes the final state ("UP" or "DOWN") and returns the result as JSON. If the status is up, a HTTP status code 200 is returned, else a 500 or 503. In this case, the Openshift probe will be considered failed by  the cluster.

In this section of the lab you will add health checks to the API Verticle.

. Add the required dependency to the pom.xml file. +
In order to use the Vert.x Health Check component, you need the following dependencies (groupId:artifactId):
* `io.vertx:vertx-health-check`
. Add a route in the `start()` method of the `ApiVerticle` class. The route uses HTTP GET, and is bound to the path "/health/readiness". The handler of this method simply ends the response.
. In the `ApiVerticle` class, create a method `health()` which tests if the `ping()` method of the `CatalogService` can be called succesfully.
* The method takes a argument a `Future<io.vertx.ext.healthchecks.Status>` object.
* If the call to `CatalogService.ping()` succeeds, complete the Future with `Status.OK`, else complete the future with `Status.KO`.
* In the `start()` method of the `ApiVerticle` class, create a `HealthCheckHandler` instance, and register the `health()` method with the handler:
+
[source, java]
----
HealthCheckHandler healthCheckHandler = HealthCheckHandler.create(vertx)
   .register("health", f -> health(f));
----
* Add a route in the `start()` method of the `ApiVerticle` class. The route uses HTTP GET, and is bound to the path "/health/liveness". Use the HealthCheckHandler instance as handler for this route.
* In the `ApiVerticleTest` class, add unit tests for the liveness and health check routes. Test both succesful and failing liveness health checks.

=== Deployment of MongoDb on OpenShift

. If not yet done so, create a project in your OpenShift environment to contain the catalog microservice application.
+
----
$ oc new-project coolstore-catalog
----
. Deploy an instance of MongoDB on OCP using the `coolstore-catalog-mongodb-persistent.yaml` template in the `<$LAB_HOME/ocp/catalog-service>` directory:
+
----
$ cd $LAB_HOME
$ oc process -f ocp/catalog-service/coolstore-catalog-mongodb-persistent.yaml -n coolstore-catalog -p CATALOG_DB_USERNAME=mongo -p CATALOG_DB_PASSWORD=mongo | oc create -f -
----
+
Note the usage of a post-deployment lifecycle hook to populate the MongoDB instance.

=== Deployment with Fabric8 Maven plugin

The fabric8-maven-plugin brings Java applications on to Kubernetes and OpenShift. It provides a tight integration into Maven and benefits from the build configration already provided. This plugin focus on two tasks: Building Docker images and creating Kubernetes and OpenShift resource descriptors.
The fabric8-maven-plugin uses the binary source build type, i.e. the artifact to be deployed is injected into the container from the local file system. The plugin uses an auto-detection mechanism to determine which image to use for the application. If needed, this mechanism can be overridden in the plugin configuration, e.g. if you want to use another Docker image to run your application. For a Vert.x application, the fabric8-maven-plugin uses the `fabric8/s2i-java:2.0` images as build image.

In the catalog project source code, the fabric8-maven-plugin is configured in the `OpenShift` Maven profile in the pom.xml file

[source,xml]
----
  <profiles>
    <profile>
      <id>openshift</id>
      <properties>
        <test.to.exclude/>
      </properties>
      <build>
        <plugins>
          <plugin>
            <groupId>io.fabric8</groupId>
            <artifactId>fabric8-maven-plugin</artifactId>
            <executions>
              <execution>
                <id>fmp</id>
                <goals>
                  <goal>resource</goal>
                  <goal>build</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
  </profiles>
----

The fabric8-maven-plugin can be configured with external configuration in the form of YAML resource descriptors which are located in the `src/main/fabric8` directory. The coolstore catalog project uses this technique to define a Router object for the application, and to configure the health check probes on the Deployment object.

. Make sure you are logged in into OpenShift and using the `coolstore-catalog` project.
+
----
$ oc project coolstore-catalog
----
. Add the _view_ role to the default service account. The coolstore application calls the Kubernetes API in order to retrieve the ConfigMap, which requires _view_ access.
+
----
$ oc policy add-role-to-user view -n $(oc project -q) -z default
----
. Create the ConfigMap with the configuration for the coolstore catalog application. The `etc` folder of the application source project contains an example of a configuration file. It defines the following configuration parameters:
* catalog.http.port: the port for the HTTP server
* connection_string, db_name, username, password: MongoDB connection parameters, used by the Vert.x MongoDB client.
+
----
$ cd $LAB_HOME/catalog-service
$ oc create configmap app-config --from-file=etc/app-config.yml
----
. Verify that the ConfigMap has been deployed:
+
----
$ oc get configmap app-config -o yaml
----
+
----
apiVersion: v1
data:
  app-config.yaml: |-
    catalog.http.port: 8080
    connection_string: mongodb://catalog-mongodb:27017
    db_name: catalogdb
    username: mongo
    password: mongo
kind: ConfigMap
metadata:
  creationTimestamp: 2017-06-06T08:50:19Z
  name: app-config
  namespace: coolstore-catalog
  resourceVersion: "19499"
  selfLink: /api/v1/namespaces/coolstore-catalog/configmaps/app-config
  uid: 2b3d7672-4a95-11e7-8788-507b9d27afbf
----
. Review the `router.yml` and `deployment.yml` YAML resource fragments in `src/main/fabric8`.
. Deploy the coolstore catalog application on OpenShift:
+
----
$ mvn clean fabric8:deploy -Popenshift
----
. Follow the output of the fabric8-maven-plugin to check the status of the deployment of the application:
+
----
[INFO] --- fabric8-maven-plugin:3.4.0:build (fmp) @ catalog-service ---
[INFO] F8: Using OpenShift build with strategy S2I
[INFO] F8: Running generator vertx
[INFO] F8: vertx: Using Docker image fabric8/s2i-java:2.0 as base / builder
[INFO] Copying files to /home/bernard/gpse/appdev_microservices_development/appdev_microservices_development_lab/catalog-service-
vertx/solution/target/docker/catalog-service/latest/build/maven
[INFO] Building tar: /home/bernard/gpse/appdev_microservices_development/appdev_microservices_development_lab/catalog-service-ver
tx/solution/target/docker/catalog-service/latest/tmp/docker-build.tar
[INFO] F8: [catalog-service:latest] "vertx": Created docker source tar /home/bernard/gpse/appdev_microservices_development/appdev
_microservices_development_lab/catalog-service-vertx/solution/target/docker/catalog-service/latest/tmp/docker-build.tar
[INFO] F8: Creating BuildServiceConfig catalog-service-s2i for Source build
[INFO] F8: Creating ImageStream catalog-service
[INFO] F8: Starting Build catalog-service-s2i
[INFO] F8: Waiting for build catalog-service-s2i-1 to complete...
[INFO] F8: Receiving source from STDIN as archive ...
[INFO] F8: ==================================================================
[INFO] F8: Starting S2I Java Build .....
[INFO] F8: S2I binary build from fabric8-maven-plugin detected
[INFO] F8: Copying binaries from /tmp/src/maven to /deployments ...
[INFO] F8: ... done
[INFO] F8:
[INFO] F8: Pushing image 172.30.1.1:5000/coolstore-catalog/catalog-service:latest ...
[INFO] F8: Pushed 0/23 layers, 0% complete
[INFO] F8: Pushed 1/23 layers, 6% complete
[INFO] F8: Pushed 2/23 layers, 10% complete
[INFO] F8: Pushed 3/23 layers, 15% complete
[INFO] F8: Pushed 4/23 layers, 21% complete
[INFO] F8: Pushed 5/23 layers, 24% complete
[INFO] F8: Pushed 6/23 layers, 29% complete
[INFO] F8: Pushed 7/23 layers, 37% complete
[INFO] F8: Pushed 8/23 layers, 44% complete
[INFO] F8: Pushed 9/23 layers, 46% complete
[INFO] F8: Pushed 10/23 layers, 48% complete
[INFO] F8: Pushed 11/23 layers, 53% complete
[INFO] F8: Pushed 12/23 layers, 57% complete
[INFO] F8: Pushed 13/23 layers, 62% complete
[INFO] F8: Pushed 14/23 layers, 67% complete
[INFO] F8: Pushed 15/23 layers, 73% complete
[INFO] F8: Pushed 16/23 layers, 79% complete
[INFO] F8: Pushed 17/23 layers, 80% complete
[INFO] F8: Pushed 18/23 layers, 81% complete
[INFO] F8: Pushed 19/23 layers, 83% complete
[INFO] F8: Pushed 20/23 layers, 87% complete
[INFO] F8: Pushed 21/23 layers, 92% complete
[INFO] F8: Pushed 22/23 layers, 99% complete
[INFO] F8: Pushed 23/23 layers, 100% complete
[INFO] F8: Push successful
[INFO] F8: Build catalog-service-s2i-1 Complete
[INFO] F8: Found tag on ImageStream catalog-service tag: sha256:4f3fffb446f525b8315b4511514e3589ca12c86cbd36a5eae31100476ffbef07
----
+
----
[INFO] --- fabric8-maven-plugin:3.4.0:deploy (default-cli) @ catalog-service ---
[INFO] F8: Using OpenShift at https://master.ocp.local.cluster:8443/ in namespace coolstore-catalog with manifest /home/bernard/g
pse/appdev_microservices_development/appdev_microservices_development_lab/catalog-service-vertx/solution/target/classes/META-INF/
fabric8/openshift.yml
[INFO] OpenShift platform detected
[INFO] Using project: coolstore-catalog
[INFO] Creating a Service from openshift.yml namespace coolstore-catalog name catalog-service
[INFO] Created Service: target/fabric8/applyJson/coolstore-catalog/service-catalog-service.json
[INFO] Creating a DeploymentConfig from openshift.yml namespace coolstore-catalog name catalog-service
[INFO] Created DeploymentConfig: target/fabric8/applyJson/coolstore-catalog/deploymentconfig-catalog-service.json
[INFO] Creating Route coolstore-catalog:catalog-service host: null
[INFO] F8: HINT: Use the command `oc get pods -w` to watch your pods start up
----
. Check the status of the deployment in the OpenShift Web console, or using the CLI.
+
----
$ oc get pods
----
+
----
NAME                          READY     STATUS      RESTARTS   AGE
catalog-mongodb-1-w132w       1/1       Running     0          1h
catalog-service-1-p1wx1       1/1       Running     0          5m
catalog-service-s2i-1-build   0/1       Completed   0          5m
----
+
image::images/coolstore-catalog-deployed.png[]
. Check the log of application pod to make sure that the application did start up correctly:
+
----
$ oc logs -f catalog-service-1-p1wx1
----
+
----
Starting the Java application using /opt/run-java/run-java.sh ...
exec java -Dvertx.cacheDirBase=/tmp -javaagent:/opt/jolokia/jolokia.jar=config=/opt/jolokia/etc/jolokia.properties -cp . -jar /deployments/catalog-service-1.0.0-SNAPSHOT-fat.jar
I> No access restrictor found, access to any MBean is allowed
Jolokia: Agent started with URL https://172.17.42.6:8778/jolokia/
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
Jun 06, 2017 8:54:00 AM com.mongodb.diagnostics.logging.JULLogger log
INFO: Cluster created with settings {hosts=[catalog-mongodb:27017], mode=SINGLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
Jun 06, 2017 8:54:00 AM io.netty.util.internal.MacAddressUtil defaultMachineId
WARNING: Failed to find a usable hardware address from the network interfaces; using random bytes: cb:d1:a2:34:6a:14:ba:6c
Verticles deployed successfully.
Jun 06, 2017 8:54:00 AM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
Jun 06, 2017 8:54:00 AM com.mongodb.diagnostics.logging.JULLogger log
INFO: Opened connection [connectionId{localValue:1, serverValue:10048}] to catalog-mongodb:27017
Jun 06, 2017 8:54:00 AM com.mongodb.diagnostics.logging.JULLogger log
INFO: Monitor thread successfully connected to server with description ServerDescription{address=catalog-mongodb:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[3, 2, 10]}, minWireVersion=0, maxWireVersion=4, maxDocumentSize=16777216, roundTripTimeNanos=1528697}
----

=== Testing the coolstore catalog application

You can test the coolstore catalog application using curl.

. Get the URL of the coolstore catalog application
+
----
$ export CATALOG_URL=http://$(oc get route catalog-service -o template --template='{{.spec.host}}')
----
. Invoke the readiness health check probe:
+
----
$ curl -X GET "$CATALOG_URL/health/readiness"
----
+
----
OK
----
. Invoke the liveness health check probe:
+
----
$ curl -X GET "$CATALOG_URL/health/liveness"
----
+
----
{"checks":[{"id":"health","status":"UP"}],"outcome":"UP"}
----
. Get the list of products in the catalog:
+
----
$ curl -X GET "$CATALOG_URL/products"
----
+
----
[ {
  "itemId" : "329299",
  "name" : "Red Fedora",
  "desc" : "Official Red Hat Fedora",
  "price" : 34.99
}, {
  "itemId" : "329299",
  "name" : "Forge Laptop Sticker",
  "desc" : "JBoss Community Forge Project Sticker",
  "price" : 8.5
}, {
  "itemId" : "165613",
  "name" : "Solid Performance Polo",
  "desc" : "Moisture-wicking, antimicrobial 100% polyester design wicks for life of garment. No-curl, rib-knit collar; special collar band maintains crisp fold; three-button placket with dyed-to-match buttons; hemmed sleeves; even bottom with side vents; Import. Embroidery. Red Pepper.",
  "price" : 17.8
}, {
  "itemId" : "165614",
  "name" : "Ogio Caliber Polo",
  "desc" : "Moisture-wicking 100% polyester. Rib-knit collar and cuffs; Ogio jacquard tape inside neck; bar-tacked three-button placket with Ogio dyed-to-match buttons; side vents; tagless; Ogio badge on left sleeve. Import. Embroidery. Black.",
  "price" : 28.75
}, {
  "itemId" : "165954",
  "name" : "16 oz. Vortex Tumbler",
  "desc" : "Double-wall insulated, BPA-free, acrylic cup. Push-on lid with thumb-slide closure; for hot and cold beverages. Holds 16 oz. Hand wash only. Imprint. Clear.",
  "price" : 6.0
}, {
  "itemId" : "444434",
  "name" : "Pebble Smart Watch",
  "desc" : "Smart glasses and smart watches are perhaps two of the most exciting developments in recent years. ",
  "price" : 24.0
}, {
  "itemId" : "444435",
  "name" : "Oculus Rift",
  "desc" : "The world of gaming has also undergone some very unique and compelling tech advances in recent years. Virtual reality, the concept of complete immersion into a digital universe through a special headset, has been the white whale of gaming and digital technology ever since Nintendo marketed its Virtual Boy gaming system in 1995.",
  "price" : 106.0
}, {
  "itemId" : "444436",
  "name" : "Lytro Camera",
  "desc" : "Consumers who want to up their photography game are looking at newfangled cameras like the Lytro Field camera, designed to take photos with infinite focus, so you can decide later exactly where you want the focus of each image to be.",
  "price" : 44.3
} ]
----
